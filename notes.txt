PRIMARY MISSION:

Be able to test current system.

1. create matrix bool indicator that finds entry points
   - pencil streamnet for entry bool
2. create matrix bool indicator that find exit points, when in a trade
   - pencil streamnet for exit bool
3. trade simulator
4. backtest
5. profit!

=======================================================================================================================================

   price -------+-----------------------------+-------------\
                |                             |              \                     +-----------\
                +--+--------\                 | sim:Basic     ]-----+----trade-----| vis:Trade  ]--------->>>
                   | st:Test ]-----trade------|              /      |              +-----------/
                +--+--------/                 +-------------/		|
				|                                                   |
			    +---<----------<------------<------------<----------+

root
│
└───app
    │   index.html
    │
    ├───bower_components
    │   <all components>
    │
    ├───js
    │   ├── modules
    │   │   main.js
    │   │
    │   └── plugins
    │       <amd enabled plugins>
    │
    scripts
    │  build.sh
    │


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% undulation beat - supporting beat

Core values

% eclectic
% ambidexterity
% stoic

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

------------------------
trade commands/actions
------------------------

enter_long: create long position
  - id? (defaults to next available id)
  - units (lot size)
  - price? (if no price, use market)
  - instrument? (defaults to stream instrument)
enter_short: create short position
  - id? (defaults to next available id)
  - units (lot size)
  - price? (if no price, use market)
  - instrument? (defaults to stream instrument)
exit: exit position
  - id? (defaults to last position started)

// set_stop: set stop value
// set_limit: set limit value

------------------------
trade events
------------------------

trade_start
  - id
  - direction (-1,1)
  - units
  - price
  - instrument?
trade_end
  - id
stop_updated
  - id
limit_updated
  - id

# DEBUG TOOLS: =============================================

// Inspect an indicator's current output buffer contents
function inspect(ind) {return chart.collection.indicators[ind].output_stream.buffer.map(function(x) {return JSON.stringify(x)}).join("\n")}

---
_.pluck(chart.components[0].indicators['test-vis'].data, "value").map(function(x) {return JSON.stringify(x)}).join("_")

# ==========================================================

##################################################

unicode single-character symbols for stream types:

☑ (0x2611) - bool
⇅ (0x21c5) - direction

##################################################


:: Rust-edition terms:
- collection -> streamnet
- timeframe -> timestep
- indicator -> formula
- stream -> stream
- indicator_instance -> formula_instance


TODO:

- rename chart_setup to chart_config?
- support circular deps on indicators
  + token_table
- pass this.event_source to on_bar_update()
-
- verify/fix resize/reposition/update/render events
- on_scale_changed() should redraw all indicators

- use obj w/ methods for vis.data, to track min/max, etc.
- 'use strict';

---
- provide enter/exit arrays to vis_update() with bars that are entering/exiting vis.data
- remove first "buffer_size" parameter from Stream() and add as option in 'params' parameter
- minrange/maxrange options for component config:
  + each take either a number (ymax-ymin) or an array [ymin,ymax]
- fix CSS: more consistency, remove repetition
- consolidate get_viewport() functions into uitools
- main menu (upon hitting e)
- status window (upon hitting s) what will show?
- fn:WeightedSum
- Pullback (x number of bars )
- daybook
- balance when on_scale_changed() is called vs. directly calling indicator's render()
- Have indicator's output stream set to target TF before its initialize() function is called (to allow for validation) [may not be feasible]
- implement cursor using canvas (canvas layered over svg chart)

- make VolVol matrix indicator with color scale
- fix render() for matrix comp
v for "pri" labels, show only last 2 digits
- enable pause on live_stream
- allows "defs" param for chart indicators to accept multiple indicators as sources

% Jurr - Summertime
% Good Guy Mikesh
---
% beat
  + 2 drywall-thumps
  + 1 popwrap
  + 1 metal pipe ding

- support for arrays of types: num[]

---

- allow for recursive types
  + template generation detects circular reference, and stops
  + field_map generation stop at circ ref, and marks it
- calculate daily pivots to start/end at 4/5pm (or whenever trading session boundary is)
- have chart artificially insert ticks on new bar start
- define min bounds for scale
- update "oanda.js" to handle multiple subscriptions from clients
- validate that indicators used in chart contain necessary vis_* functions on init
- Indicators added to chart which output a different TF are automatically converted to chart's TF w/ differential
- consolidate ticks into tickvols during heavy volume
- support for chart-level indicators
- stop_propagation() to prevent update events from continuing dependency tree
- update cursor labels on scaled_changed
- allow color scales to support opacity OR separate defs for day/night themes
- stream:TickThrottle


- Training Sets

= Create neural network that has input: candle data for x bars (10), trendline position (and slope?); outputs: confidence that trendline is active

= Sqlite backend for general-purpose data storage/retrieval

DS string: "sqlite:dbname"

tables:
meta - key,value
data - serialization of a stream or group of streams

= Allow for array of input streams for indicator input in collection def

meta:

. qualifiers need to be used for matrix


input:

========================================================================================
QUALIFIER

- Qualifier: A special datatype that represents a calculation of one or several inputs that produces a value

A qualifier refers to an equation or number that qualifies whether a target measurement is a signal for some event,
i.e. to signal trade entry/exit, stop/limit movement, or serve as input for further calculation.  A qualifier can take several
forms, each of which may determine the context is which it is applied.

Qualifier types:

- confidence
- directional confidence
- normal distribution
- gamma distribution
-

fields: [type, data, notes, level]
qualifier types: [bool, confidence, direction_confidence, pmf]

Fields:

$<type> (*) - <type> defines the type of qualifier, and establishes the format expected in the value, where the qualifying parameters are stored
notes (string) - notes to appear on chart as comments
level (int) - a value from 1 - 5 signifying the "importance" of qualfier result (used for emphasis on chart)

Example qualifiers:

{
	$pmf: []
	notes: "",
	level: 1
}

========================================================================================
DATA PROVIDER

- maintains connection to sources, and client to server
-



========================================================================================
Major Objectives:

- Chart
  + Selections
  + Chart-level indicators
    . Comments
	. Sound (alerts)
  + Daybook
    . Allow for quick visual backtesting on client for past data
- Data Management
  + DataProviders for client/server
  + single dataprovider instance manages several datasource instances, provides unified interface to multiple sources
  + OANDA handle multiple subscriptiosn
  + SQLite
  + client-side storage (Web SQL, IndexedDB, Storage)
  + supports comprehensive backtesting/optimization on server
- Indicator Management
  + collection visualization
  + import/export via dataprovider to/from datasources
- Money Management
- Account management
  + virtual accounts created from real accounts (like substream objects from streams)
  +
- Documentation
- Neural Networks
  + scatterplot matrix: http://bl.ocks.org/mbostock/4063663
- ZigZag, Trendlines, S/R, Fib retracements
- Trade Simulation and analysis


====================================

! issue: timeframe unknown at time of indicator init

- ATR pip rounding based on currency and pipsize (in VolVol, and add optional )
- validate that all inputs to indicators are objects
- support for arrays (i.e. num[]) to make any type an array of that type
- "suppress" vis option to omit subfields from chart
- "@collection" preprocessor to load other collection inline
- glass pane - owned by chart, move titles to it
- remove NaN from indicator outputs, handle Null cases
- when rendering volume-based indicators (KVO, OBV), account for volume/bar when colorizing by slope
- revise var names, class names, id names
- _.defaults() to work for subobjects in config (y_scale)
- redraw pivots only on new bars

---------

- Convexity/Concavity indicator:
  Outputs:
	dir - direction of concavity (-1 opens downward)
	span - width in bars
	range - range in pips
	skew

- "dataprovider.js" amd module for centralized data management from client
  + other names: dataportal,
  + loads arbitrary files from /data
  + loads all-at-once or aynchronously line-by-line
  + uses socket.io to connect client to server
- equivalient server-side version defined in local/dataprovider.js

- scaleWeight - scales weight according to criterion output.

! Fix buffer_size for identity indicator (for now leave default of 200 for all)
! indicators depended on by others need to have the same minbars as them

- register() some events from a sub-delegate to propagate up
- register_all() - register all events
- track unique IDs for delegates/indicators
- prevent calling substream/simple from on_bar_update() (init only)

% I notice he didn't include array-based languages, like APL and J

% https://news.ycombinator.com/item?id=8216865
% Can someone explain why deep learning articles are receiving attention rather than, say, Support Vector Machines / kernel-based methods of pattern analysis?
% Support vector machines are not particularly interesting. They are just perceptrons with a lot of math. So ultimately souped-up linear classifiers. If you start learning the kernel in an SVM you get a deeper model. A neural net using the hinge loss and an L2 penalty on the weights is basically a primal SVM.

### Low priority / Long term:

- indicators/streams can have owners
  + for drilling down to raw data
  + to propagate events upstream;

- '~' can be applied to indicator output fields to suppress output of that field from the collection, but still accessible to other indicators of that collection
- ["tran:Intervals", lower_bound, upper_bound, intervals=3, unsigned=false]
- ["Stdev", period]
- Patterns for bar data (pat indicator/delegate group) ?
- add stream.index(idx) and stream.get_index() methods
X output names starting with '~' will be suppressed from output record (internal to indicator_collection only)
- Fix tsRSI
- Compare ntKVO to NT output
- confirm CCI

==================================================

Stream:
- Circular array buffer with accessor functions
- Optionally defines a timeframe (required if any dependent indicators will do tf conversion)

Stream Types:
- indicator definition:
  + input
    ()

StreamGroup(?):
- map of streams keyed by id
- behaves like a stream

Indicators:
- Deterministic: same input always produces same output
- Can create internally: streams, indicators
- Accepts array of input streams for input
- Writes to and modifies output stream for output
- Input/Output are synchronous
- supported on both client and server
- delicate, detailed and accurate (strong unit-testing)

Delegates:
- Non-deterministic: can rely on external input, randomization
- Can create internally: streams, indicators, indicator_collections, delegates
- Can form complex hierarchies of delegates doing complex calculations, API/DB interactions, etc.
- Accepts array of input streams for input
- Can emit events to perform various actions: trading, debugging, calling external resources, etc.
- No output stream -- uses events for output
- Input/Output are asynchronous
- All operations are done asynchronously
- only supported on server
- empowered, organized, diverse

AWsm:
- Adjusted Weighted Sum Model

wsm.crit.decay(.3) - decays exponential every tick
wsm.crit.tick()
wsm.crit.linger(3) - have set value linger for 3 ticks
wsm.crit.setValue(4) - set input value for criterion
wsm.crit.setWeight() - sets the weight for criterion and normalizes all
wsm.crit.set(null) - removes from equation
wsm.crit.thres(.5) - threshold for criterion to be included in equation

- function key shows popup graphic + descs on hover
===================================================
Charting/Visualization:

Chart:
- contains and manages components as an array "components"
- defines an "anchor" indicator that controls time and x-axis
? holds and manages data for components
- margins: left, right
- controls chart width based on bar count + bar width + bar padding + left/right margins
- controls x-axis and labels

Component:
- manages a graphical subsection of a chart
- controls height of component
- controls top/bottom margins for component
- controls y-scale, y-ticks and y-labels for component
- calls "vis_" functions in indicators (IndicatorComponent)

===================================================

console commands:

oanda:EUR_USD:m5()
chartgroup

primary, secondary, tertiary, quaternary, quinary, senary, septenary, octonary, nonary, and denary.
pri, sec, ter, qua, qui, sen, sep, oct, non, den

%%%

Creativity and Deviating from the Norm

- comparison to mutations

========================================
AWSM Test:

var Awsm = require("./tools/awsm.js");

var awsm = new Awsm({
    critA: {w: 0.5, v: 100},
    critB: {w: 2, v: 20}
}, "awsm-test");
awsm.critA.scale.domain([1,100]);
awsm.critB.scale.domain([1,100]);

console.log("DUMP:", awsm.dump());
console.log("EVAL:", awsm.eval());

console.log("exit");